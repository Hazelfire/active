%% -*- LaTeX -*-

\documentclass{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% lhs2TeX

%include polycode.fmt

% Use 'arrayhs' mode, so code blocks will not be split across page breaks.
\arrayhs

\renewcommand{\Conid}[1]{\mathsf{#1}}

\newcommand{\cons}[1]{\mathsf{#1}}

%format const = "\cons{const}"
%format inf   = "\infty"
%format max   = "\cons{max}"
%format min   = "\cons{min}"

%format ===    = "\equiv"
%format <>     = "\diamond"
%format mempty = "\varepsilon"

%format a1
%format a2
%format l1
%format l2
%format r1
%format r2

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Package imports

\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{proof}
\usepackage{url}
\usepackage{xspace}
\usepackage{xcolor}
\usepackage{natbib}
\usepackage[all]{xy}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Comments

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\newcommand{\bay}[1]{\authornote{blue}{BAY}{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Diagrams

\usepackage{graphicx}
\usepackage[outputdir=diagrams/]{diagrams-latex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Math typesetting

% Use sans-serif for math operators
\DeclareSymbolFont{sfoperators}{OT1}{cmss}{m}{n}
\DeclareSymbolFontAlphabet{\mathsf}{sfoperators}

\makeatletter
\def\operator@@font{\mathgroup\symsfoperators}
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Prettyref

\usepackage{prettyref}

\newrefformat{fig}{Figure~\ref{#1}}
\newrefformat{sec}{\S\ref{#1}}
\newrefformat{eq}{equation~\eqref{#1}}
\newrefformat{prob}{Problem~\ref{#1}}
\newrefformat{tab}{Table~\ref{#1}}
\newrefformat{thm}{Theorem~\ref{#1}}
\newrefformat{lem}{Lemma~\ref{#1}}
\newrefformat{prop}{Proposition~\ref{#1}}
\newrefformat{defn}{Definition~\ref{#1}}
\newrefformat{cor}{Corollary~\ref{#1}}
\newcommand{\pref}[1]{\prettyref{#1}}

% \Pref is just like \pref but it uppercases the first letter; for use
% at the beginning of a sentence.
\newcommand{\Pref}[1]{%
  \expandafter\ifx\csname r@@#1\endcsname\relax {\scriptsize[ref]}
    \else
    \edef\reftext{\prettyref{#1}}\expandafter\MakeUppercase\reftext
    \fi
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Semantic markup

\newcommand{\eg}{\emph{e.g.}\xspace}
\newcommand{\ie}{\emph{i.e.}\xspace}

\newcommand{\term}[1]{\emph{#1}}

\newcommand{\pkg}[1]{\texttt{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\section{Parallel composition and |XActive|}
\label{sec:par-comp}

Taking our cue from \citet{matlage2011every}, we start with the
following preliminary semantics for |Active|, a time-varying value
with a beginning, middle, and end:

\begin{spec}
XActive t a === (t, t -> a, t)
\end{spec}

\begin{center}
\begin{diagram}[width=200]
import ActiveDiagrams
dia = a1 <> tl
\end{diagram}
\end{center}

That is, the semantics of |Active| is a triple of values $(t_s, f, t_e)$,
consisting of
\begin{itemize}
\item an absolute start time $t_s$,
\item a function $f$ from time to values, and
\item an absolute end time $t_e$.
\end{itemize}
The function $f$ is total on the interval $[t_s, t_e]$ but is
undefined outside it.  (Note that we take $[t_s, t_e]$ to denote the
empty interval when $t_s > t_e$.)  As for the type of time values $t$,
we assume that it is bi-infinite, has a linear order, and forms an
affine space together with an associated type $d$ of
\emph{durations}.  In particular it does \emph{not} matter whether
time is continuous or discrete; our model will work in either case.

Our first goal is to enable \emph{parallel composition} of
|Active|. The first question is how the start and end times should be
combined.  There are really two choices: to take the union of the
intervals or the intersection.  Our novel contribution is to take the
\emph{intersection}, rather than the union as in some past
approaches~\citep{matlage2011every, hudak2004algebraic}.  At first
blush union might seem more useful, but we argue in
\pref{sec:why-not-union} why intersection gives us a cleaner and more
useful semantics.

Given a semigroup structure on the type |a|, we can now define the
parallel composition |(a1 <> a2)| of two |Active t a| values as the
value whose interval is the intersection of the intervals of |a1| and
|a2|, with values generated by combining the values of |a1| and |a2|
pointwise (which is well-defined since, by definition, both |a1| and
|a2| are defined everywhere on the intersection of their intervals).
\begin{center}
\begin{diagram}[width=200]
import ActiveDiagrams
as :: Diagram Cairo R2
as = cat' unitY with {sep = 0.5} [a12, a2, a1]
dia = (   vrule (height as) # translateX (-1)
       <> vrule (height as) # translateX 3
      )
      # alignB # translateY (-1.5)
      # lw 0.1 # dashing [0.3,0.2] 0
   <> as
   <> tl
\end{diagram}
\end{center}
Abstractly, we can construct this semigroup as the product of semigroup
structures on the three components of |Active|: namely, the |max|
semigroup for start times, the usual lifted semigroup for functions, and the
|min| semigroup for end times.

The next natural question is whether we can extend this semigroup to a
monoid.  On the face of it, we are stymied by the fact that |max| and
|min| on $t$ do not have identity elements, since we have assumed that
$t$ is bi-infinite.  However, this suggests adjoining distinguished
identity elements to the start and end types, forming a new type
|XActive|\footnote{The |X| stands for ``eXtended'', or possibly
  ``fiXed''.  Or perhaps it stands for ``eXcellent''.}:
\begin{spec}
type XActive t a = (-inf + t, t -> a, t + inf)
\end{spec}
\begin{center}
\begin{diagram}[width=200]
import ActiveDiagrams
dia = a1R <> tl
\end{diagram}
\end{center}
That is, instead of being limited to finite start and end times as
|Active| was, an |XActive| value may potentially ``start at time
|-inf|'' (that is, be defined for all values of $t \leq t_e$) and/or
``end at time |inf|''.  The identity for parallel composition is thus
given by |(-inf, const mempty, inf)|, that is, the |XActive| which is
constantly the identity value at all times.

\section{Why not union?}
\label{sec:why-not-union}

\citet{matlage2011every} explicitly take the \emph{union} of intervals
(to be precise, the smallest interval containing both input intervals)
when forming the parallel composition of two |Active| values.  Early
versions of the \pkg{active} library~\citep{yorgey2011active} made the
same choice.  \todo{talk about Hudak temporal media paper(s), need to
  figure out where they stand on these issues.}  Indeed, on the face
of it, taking the union seems more ``useful'': one typically wants to
compose animations out of disparate parts which do not all cover the
same interval.  For example, I might want to have a circle moving
across the screen, and then when it is halfway something else appears
and does something\dots and so on.  This sounds exactly like a union
semantics for parallel composition.  However, as we will show later,
using our semantics, one \emph{can} compose things in this sort of
``uniony'' way, but it ends up being a derived operation, and should
not be taken as \emph{primitive}.  Ultimately this is a good thing,
because it gives the user more control over how the unioning happens.
In the end, we have come to the conclusion that taking the
intersection of intervals gives a cleaner, more natural, and
ultimately more useful semantics.  We can justify this decision in a
few different ways.

First, the natural identity element for parallel composition based on
union would be something like |(+inf, const mempty, -inf)|, which is
nonsense.  In practice we end up adjoining a new, distinguished
identity element, leading to the need for many special-case analyses
to handle it appropriately.  On the other hand, as we have seen above,
the natural identity element for intersection has a natural
interpretation, and needs no special case.

Second, combining via union forces us to decide what values should be
used \emph{outside} the interval of an active value, since we may need
a value to combine.
\begin{center}
\begin{diagram}[width=200]
import ActiveDiagrams
dia = (cat' unitY with [a1X,a2X]) <> tl

a2X = mconcat
  [ a2
  , text' "?" # scale 0.7 # translateX (-3.5)
  , xactiveRect (-6) (-1) (blend 0.7 blue white)
  ]

a1X = mconcat
  [ a1
  , text' "?" # scale 0.7 # translateX 4
  , xactiveRect 3 5 (blend 0.5 red white)
  ]
\end{diagram}
\end{center}
Essentially, we are forced to revise the semantics: where previously
we said that the function of an active value is simply undefined
outside the interval, we would now have to specify the values the
function takes on outside the interval. We have a few choices.

\begin{itemize}
\item One seemingly sensible choice is |mempty|, which works as long
  as there is a |Monoid| instance for the base type |a|.  However,
  more generally, we want not only a monoidal parallel composition
  operation, but also an |Applicative| instance for active values
  (from which parallel composition can be derived).  Unlike parallel
  composition itself, the |Applicative| instance cannot depend
  on |Monoid| instances for the base types, but implementing it
  leads to the same need for values outside an active's interval.

\item Another option (the one taken by~\citep{matlage2011every}) is
  to ``clamp'' the value of the function to its value at the
  endpoints, \ie\ $f(t) = f(t_s)$ for all $t < t_s$ and $f(t) =
  f(t_e)$ for all $t > t_e$.  However, this may not always be what
  the user wants.

\item A final option (taken by earlier versions of the \pkg{active}
  package) is to simply require that the function always be defined
  at all times in the first place.  However, this requires the user
  to reason about the behavior of active values over the whole
  timeline and not just on their interval, in some sense defeating
  the point of having an interval in the first place.
\end{itemize}

The point is that there are multiple viable options, with no one
option standing out as obviously the most correct or fundamental.
This in and of itself is a strong hint that union should not be
taken as primitive.  It is easy to imagine users wanting all three
of the behaviors described above; baking any one of them into the
primitive semantics of parallel composition necessitates awkward
workarounds when the user wants a different behavior.

As far as expressiveness goes, it does not matter that much: given
appropriate extension and restriction operations to modify the
intervals of active values, unioning and intersecting parallel
composition are inter-definable.

\section{Sequential composition and |FActive|}
\label{sec:seq-comp}

It's instructive to begin by trying to work out a semantics for
sequential composition of |XActive|. The idea, of course, is the end
time of the first |XActive| should be matched up with the start time
of the second.
\begin{center}
\begin{diagram}[width=200]
import ActiveDiagrams

dia = vcat' with {sep = 1}
      [ hcat' with {sep = 2}
        [ xactiveD (-3) 1 red
        , text' ";"
        , xactiveD (-4) 3 blue
        ] # centerX
      , text' "="
      , result # centerX <> phantom tl
      ]

result = (draw $ xactive' (-3) 8 (xactiveRect (-3) 1 red |||||| xactiveRect 1 8 blue))
\end{diagram}
\end{center}
%$
However, this clear intuition has two big problems lurking in the details.
First, what happens at the precise time of transition between the two
values?  Second, how should the resulting composed value be positioned
in time?  We will attack each problem in turn.

\subsection{Transitions and endpoints}
\label{sec:endpoints}

When two actives are composed sequentially, what value does the
composed active take on at the precise transition between the two?
\begin{center}
\begin{diagram}[width=200]
import ActiveDiagrams

dia = result # centerX <> phantom tl

result = atop (text' "?" # scale 0.7 # translateX 1). draw . xactive' (-3) 8 $ hcat
  [ xactiveRect (-3) 1 red
  , vrule 3 # lw 0.1 # dashing [0.1,0.1] 0 # lc grey
  , xactiveRect 1 8 blue
  ]
\end{diagram}
\end{center}
%$
The problem is that at the precise transition time we have two values
of the underlying type, one from each active.  Somehow we have to pick
a single value for the combined active to take on at that time.
Options include:
\begin{itemize}
\item We could combine the two values according to some semigroup operation.
  However, this is not a very attractive option; intuitively, sequential
  composition should not require any constraints on the base type at
  all.
\item We could simply take the second value and discard the first, or
  take the first and discard the second. \todo{what do previous
    versions of active do? this?} The problem is that this represents
  an arbitrary choice, which we should be wary of baking into our
  semantics.  As with unioning parallel composition, we take this as a
  sign that we should take something yet more primitive which avoids
  an arbitrary choice, and expose the choice to the user.
\end{itemize}

Our solution is to refine the semantics yet again. The idea is to
track \emph{whether an active value is defined at its endpoints}, and
only allow sequential composition when one value is defined at the
endpoint (closed) and one is not (open). The semantics of an active
value will still consist of a triple |(-inf + t, t -> a, t + inf)|.
However, we also add two type indices, one for each endpoint, which
are taken from a set $\{\infty,|C|,|O|\}$.  Their meanings are as
follows:
\begin{itemize}
\item $\infty$ means that the endpoint is \emph{infinite}, that is,
  $\pm \infty$.
\item |C| means that the endpoint is \emph{closed}, that is, the
  function is defined \emph{at} the endpoint.  We will continue to
  illustrate such endpoints with a solid black line.
\item |O| means that the endpoint is \emph{open}, that is, the
  function is defined for values up to \emph{but not including} the
  endpoint.  We will draw such endpoints using a dotted grey line.
\end{itemize}

Here are just a couple examples taken from the (nine) types which are now possible, with a
representative illustration for each:

\begin{itemize}

\item |XActive O C t a|---a finite interval, closed at the right
  endpoint but open on the left.
\begin{center}
\begin{diagram}[width=200]
import ActiveDiagrams

dia = oc <> tl

oc = draw $ XActive (O (-6), r, C 3)  -- $
  where
    r = xactiveRect (-6) 3 red
\end{diagram}
\end{center}

\item |XActive inf O t a|---an open endpoint on the right, infinite on
  the left.
\begin{center}
\begin{diagram}[width=200]
import ActiveDiagrams

dia = infO <> tl

infO = draw $ XActive (I, r, O 2)  -- $
  where
    r = cat' unit_X with
      [ xactiveRect (-2) 2 red
      , fade 7 0 0.5 50
      ]
\end{diagram}
\end{center}
\end{itemize}

Now there are two sequential composition operators, with types given by
\begin{spec}
seqR  ::  XActive l1 O t a  ->  XActive C r2 t a  ->  XActive l1 r2 t a
seqL  ::  XActive l1 C t a  ->  XActive O r2 t a  ->  XActive l1 r2 t a
\end{spec}

|seqR| gives rise to a semigroup operation on |XActive C O t a|
(without the need for any constraints on |a|!), and similarly for
|seqL| and |XActive O C t a|.

Note that this also neatly handles the problem, noted earlier, of
trying to sequentially compose infinite active values.  We can
sequence, say, an |XActive inf O| and |XActive C O| (resulting in
|XActive inf O|), but the types prevent us from sequencing, say, an
|XActive C inf| with anything to its right.

It is a bit awkward that we need two different sequential composition
operators.  In some sense, there is really only one, with a type
something like
\begin{spec}
seq  :: (r1,l2 `elem` {O,C}, r1 /= l2),
     => XActive l1 r1 t a -> XActive l2 r2 t a -> XActive l1 r2 t a
\end{spec}
but it is not clear how best to express this type in such a way that
|seq| is convenient to use.

\subsection{Locations and translations}
\label{sec:locations}

 But where should the
resulting composite |XActive| be placed in time?  The main concern is
that we want sequential composition to be associative.  One sensible
choice is to leave the first |XActive| where it is, and translate the
second so its start time coincides with the end time of the first:
\begin{center}
\begin{diagram}[width=200]
import ActiveDiagrams

dia = vcat' with {sep = 1}
      [ xactiveD (-3) 1 red  <> tl
      , text' "+" -- TODO pick better symbol for operator
      , xactiveD (-4) 3 blue <> tl
      , text' "="
      , result
      ]

result = (draw $ xactive' (-3) 8 (xactiveRect (-3) 1 red |||||| xactiveRect 1 8 blue))
   <> tl
   -- TODO draw a blue arrow showing the translation of the second value
\end{diagram}
\end{center}
%$
It is easy to verify that this operation is associative.\footnote{The
  astute reader will already be wondering about values with infinite
  start or end times.  We will return to deal with that complication
  shortly.}  However, the asymmetry is already a bit unsettling:
another valid choice would be to translate the first value and leave
the second unchanged.  Or we could always center the resulting
|XActive| with respect to time $0$, or place its start time at time
$0$, or\dots

In and of itself this plethora of choice is not necessarily a problem;
we could just pick the most sensible-seeming option and leave it at
that.  However, it points at a deeper problem, which comes into
sharper focus when we consider what the identity element for
sequential composition might be.  Just for the sake of concrete
examples, let us assume that we have chosen the semantics for
sequential composition illustrated above, where the second value is
translated so that it follows the first.

% type FixedActive t a = (-inf + t, t -> a, t + inf)
%   -- closed, i.e. defined on x <= t <= y.
%   -- undefined outside the interval.

%   -- Semigroup and Monoid for this reqiure Semigroup and Monoid for a.

%   -- Have Applicative for this.

% type FreeActive t a = (d, t -> a)
%   -- d \in [0 .. inf)   t in [0, d)

%   -- Semigroup and Monoid for this do NOT require Semigroup and Monoid
%   -- for a.

%   -- No Applicative.


% data Bound1 = Inf | Closed

% type XActive (l :: Bound1) (r :: Bound1) t a = ...
% -- combination take minimum (stacking)
% (<>) :: XActive l1 r1 t a ->  XActive l2 r2 t a ->  XActive (MIN l1 l2) (MAX r1
% +r2) t a

% ((Additional: perhaps we just have two types here
%    XInfActive   -- Which *is* a Behavior
%    XActive --

% This would simply things
%   * less phantoms floating around.
%   * Only XActive would map to FActive.
% ))

% data Bound2 = Inf | Closed | Open       -- Bound is a kind

% -- type d = Diff t in this type
% type FActive (l :: Bound2) (r :: Bound2) d a =
% -- combination sequences them (beside)
% (<>) :: (Join r1 r2) => XActive l1 r1 t a ->  XActive l2 r2 t a ->  XActive l1
% +r2 t a

% I like the phantoms here.

% ((Additional:: perhaps FActive should only be finite???))

\bibliographystyle{abbrvnat}
\bibliography{active-semantics}

\end{document}
